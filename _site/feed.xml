<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Curtis</title>
    <description>Curtis&#39;s Blog</description>
    <link>http://chenbingshu.com///</link>
    <atom:link href="http://chenbingshu.com///feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 12 Jul 2016 18:10:38 +0800</pubDate>
    <lastBuildDate>Tue, 12 Jul 2016 18:10:38 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>推荐阅读</title>
        <description>&lt;p&gt;推荐阅读文章列表(新旧排序):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coolshell.cn/articles/17381.html&quot;&gt;性能测试应该怎么做？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/outsystems-experts/beyond-console-debugging-tricks-f7d0d7f5df4#.vwo17tm9f&quot;&gt;Beyond Console Debugging Tricks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2016/05/super-small-web-gesture-library-alloyfinger-released/&quot;&gt;alloyfinger手势库&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</guid>
        
        <category>推荐</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>如何在页面发送通知消息</title>
        <description>&lt;p&gt;如果你的网站需要在用户登陆或者在某些特定时刻向用户发送通知。&lt;/p&gt;

&lt;p&gt;这个webapi可能会起到效果&lt;/p&gt;

&lt;h2 id=&quot;notification&quot;&gt;Notification&lt;/h2&gt;

&lt;p&gt;Web Notifications API 使页面可以发出通知，通知将被显示在页面之外的系统层面上（通常使用操作系统的标准通知机制，但是在不同的平台和浏览器上的表现会有差异）。这个功能使  web 应用可以向用户发送信息，即使应用处于空闲状态。最明显的用例之一是一个网页版电子邮件应用程序，每当用户收到了一封新的电子邮件都需要通知用户，即使用户正在使用另一个应用程序。&lt;/p&gt;

&lt;p&gt;诸如在线团队协作平台(如tower)或者聊天系统,都需要主动向用户发送通知,让用户可以及时收到最新动态&lt;/p&gt;

&lt;p&gt;tower就是通过这个接口像用户发送通知消息的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;权限&lt;/h2&gt;

&lt;p&gt;使用Notification接口时需要像用户发送授权请求(如获取用户地址位置信息等需要用户隐私的接口都需要用户授权)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Notification.requestPermission( function(status) {

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;仅当status为granted时表示用户接受通知&lt;/p&gt;

&lt;p&gt;status有三种状态:default,granted,denied&lt;/p&gt;

&lt;p&gt;*default一般是用户未处理授权请求&lt;/p&gt;

&lt;p&gt;*granted表示用户接受通知的授权&lt;/p&gt;

&lt;p&gt;*denied表示用户拒绝接受通知&lt;/p&gt;

&lt;h2 id=&quot;notification-1&quot;&gt;Notification对象&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var notification = new Notification(title,{
    body:string,
    icon:imageUrl
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notification对象有三个参数,分别是通知标题,通知内容,还有图标&lt;/p&gt;

&lt;p&gt;显示效果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160701/notification.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;回调函数&lt;/h2&gt;

&lt;p&gt;notification有4个回调函数&lt;/p&gt;

&lt;p&gt;*onshow:当通知被显示给用户时触发。&lt;/p&gt;

&lt;p&gt;*onclick:当用户点击通知时触发。&lt;/p&gt;

&lt;p&gt;*onclose:当通知被关闭时触发。&lt;/p&gt;

&lt;p&gt;*onerror:当通知发生错误的时候触发。这通常是因为通知由于某些原因而无法显示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Notification.requestPermission( function(status) {

    var notification = new Notification(&quot;标题&quot;);

    notification.onshow = function(){};

    notification.onclick = function(){};

    notification.onclose = function(){};

    notification.onerror = function(){};

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/notification/Using_Web_Notifications&quot;&gt;接口文档&lt;/a&gt;);&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</guid>
        
        <category>通知</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>js节流throttle函数</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;节流函数&lt;/h2&gt;

&lt;p&gt;在前端页面,常出现用户频繁操作dom元素导致需要频繁更新视图或者发送请求。&lt;/p&gt;

&lt;p&gt;如果是后者的话,还可能会出现异步请求结果返回与发送时间的不顺序。&lt;/p&gt;

&lt;p&gt;常用于解决这种问题的一个方法就是通过节流函数,把用户短时间内的频繁操作进行累加,最后一次执行&lt;/p&gt;

&lt;p&gt;这样不仅提高性能而且更防止了上面提到的异步请求时间不同步的问题&lt;/p&gt;

&lt;p&gt;在前端实现节流函数一般是使用定时器实现&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最简单的节流函数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function throttle(){
    if(timer){
        clearTimer(timer)
    }
    timer = setTimeout(function(){},delay);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是最简单的节流函数。通过判断是否已经存在定时器,过滤掉用户之前的操作,直到delay计时完才进行函数执行&lt;/p&gt;

&lt;h2 id=&quot;underscorethrottle&quot;&gt;underscore的throttle&lt;/h2&gt;

&lt;p&gt;underscore是一个又好又快又小的库,快主要是因为他是采用函数式编程(来源于一位老师的话)&lt;/p&gt;

&lt;p&gt;underscore也听过了如上的throttle函数(&lt;a href=&quot;http://underscorejs.org/#throttle&quot;&gt;英文文档&lt;/a&gt;,&lt;a href=&quot;http://www.css88.com/doc/underscore/#throttle&quot;&gt;中文文档&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;来自官方的一个使用例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var throttled = _.throttle(updatePosition, 100);
$(window).scroll(throttled);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;window的resize和scroll都是会频繁触犯事件的。&lt;/p&gt;

&lt;p&gt;所以通过throttle函数加以过滤可以大大提高渲染性能&lt;/p&gt;

&lt;h2 id=&quot;vuedebounce&quot;&gt;vue的debounce&lt;/h2&gt;

&lt;p&gt;vue框架自带的input的debounce实现也是节流函数的一种。(&lt;a href=&quot;https://vuejs.org/guide/forms.html#debounce&quot;&gt;文档&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;并且对于点击等用户主动触发的事件同样可以通过设置debounce来实现。&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Jun 2016 18:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/js%E8%8A%82%E6%B5%81throttle%E5%87%BD%E6%95%B0/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/js%E8%8A%82%E6%B5%81throttle%E5%87%BD%E6%95%B0/</guid>
        
        <category>throttle</category>
        
        <category>节流</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>web scroll的滚动惯性</title>
        <description>&lt;p&gt;在上个公司的最后一个版本。( &lt;a href=&quot;http://ichuanyi.com/m/page/tomorrow_recommend/&quot;&gt;传送门&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;入口放在app的主页,所以对页面的动画效果和性能(流畅度)有较大的要求&lt;/p&gt;

&lt;p&gt;页面的在交互上做了较多动画,属于交互比较复杂的单页应用&lt;/p&gt;

&lt;p&gt;其中用户在点击顶部的”地址栏”,底部的”再推荐”,以及无推荐次数之后点击”再推荐” 这三部分弹出来的页面&lt;/p&gt;

&lt;p&gt;是显示在原本主要内容层级之上的,position值为fixed&lt;/p&gt;

&lt;p&gt;在提测时候发现在native内滚动这种长页面的时候,当用户手一离开屏幕时就会停止滚动&lt;/p&gt;

&lt;p&gt;该开始以为是用户的一系列touch事件在dom冒泡了。&lt;/p&gt;

&lt;p&gt;然后在滚动的元素容器设置了event.stopPropagation()事件阻止所有事件的冒泡&lt;/p&gt;

&lt;p&gt;发现并没有什么乱用&lt;/p&gt;

&lt;p&gt;最后在mozilla的开发者文档找到了-webkit-overflow-scrolling&lt;/p&gt;

&lt;p&gt;然后通过设置该属性值为touch竟然生效了!!!!!!!&lt;/p&gt;

&lt;p&gt;!!!!!&lt;/p&gt;

&lt;p&gt;mozilla对该属性是这么描述的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   The -webkit-overflow-scrolling CSS property controls whether or not touch devices use momentum-based scrolling for the given element.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该css属性控制是否滚动是基于动量的。。。这翻译听不下去了&lt;/p&gt;

&lt;p&gt;就是看你滚动是否是需要滚行吧!!这么翻译果然好多了&lt;/p&gt;

&lt;p&gt;该属性可设置两种值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto:设置为auto时,用户的手离开屏幕即停止滚动

touch:设置为touch时,用户手离开屏幕时会基于之前的动量递减(即保持一定的惯性)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-overflow-scrolling&quot;&gt;官方解释&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jun 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/webscroll%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%83%AF%E6%80%A7/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/webscroll%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%83%AF%E6%80%A7/</guid>
        
        <category>scroll</category>
        
        <category>惯性</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>backbone使用心得</title>
        <description>&lt;p&gt;从实习工作到现在已经一年多，公司web前端的客户端主要框架是backbone＋underscore＋artTemplate+jquery libs。经历了从混合着服务端语法到前端完全分离的开发模式。在项目重构中主要负责购物流程和订单这一块，虽然也意识到backbone这种mvc的短板。但是作为经典的前端mvc框架，还是很有必要学习了解一下&lt;/p&gt;

&lt;h2 id=&quot;backbone&quot;&gt;backbone简介&lt;/h2&gt;

&lt;p&gt;经典的前端mvc框架( &lt;a href=&quot;http://http://backbonejs.org/&quot;&gt;backbone官网&lt;/a&gt; , &lt;a href=&quot;http://www.css88.com/doc/backbone/&quot;&gt;中文文档&lt;/a&gt; ),主要给开发者提供了model，view，collection等结构，并提供丰富的事件机制及route功能&lt;/p&gt;

&lt;h2 id=&quot;model&quot;&gt;model&lt;/h2&gt;
&lt;p&gt;主要用于数据交互和业务逻辑处理，开发者一般是从backbone.model继承&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var model = Backbone.Model.extend({
	defaults:{
		name:&#39;curtis&#39;
	},
	initialize:function(){
		
	}
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就声明了一个从backbone.model继承的model变量，变量中的defaults是用于声明变量的一些默认属性，可以通过如下方法获取到默认属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var model1 = new model();
model1.get(&#39;name&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面会讲到model和view的结合使用&lt;/p&gt;

&lt;h2 id=&quot;modelgetset&quot;&gt;model的get和set方法&lt;/h2&gt;

&lt;p&gt;get：获取当前model某属性的值&lt;/p&gt;

&lt;p&gt;set：设置当前model某个属性的值，可以单个属性，也可以为一个json对象,设置了属性值之后会触发change事件，可通过设置view来监听model某属性来驱动视图进行更新&lt;/p&gt;

&lt;h2 id=&quot;initialize&quot;&gt;initialize&lt;/h2&gt;
&lt;p&gt;view对象的构造函数,即实例化对象的时候调用&lt;/p&gt;

&lt;h2 id=&quot;view&quot;&gt;view&lt;/h2&gt;

&lt;p&gt;于2016.06.29继续写了&lt;/p&gt;

&lt;p&gt;view是backbone的提供的视图结构,对于简单的单页应用来说(SPA)是最重要的部分;&lt;/p&gt;

&lt;p&gt;因为简单的单页应用其实并不需要通过control层来实现model和view的,两者之间增加一个control层&lt;/p&gt;

&lt;p&gt;反而使得框架接口变得复杂&lt;/p&gt;

&lt;h2 id=&quot;events&quot;&gt;events&lt;/h2&gt;

&lt;p&gt;events主要是绑定了当前模块试图的一些绑定事件,使用方法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var view = Backbone.View.extend({

  events: {
    &quot;click .testBtn&quot;:&quot;bindBtn&quot;
  },

  bindBtn:function(){
    //具体实现
  }

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;initialize-1&quot;&gt;initialize&lt;/h2&gt;
&lt;p&gt;view对象的构造函数,即实例化对象的时候调用&lt;/p&gt;

&lt;h2 id=&quot;el&quot;&gt;el&lt;/h2&gt;

&lt;p&gt;backboneView的一个重要属性,el是当前模块对应的dom元素,&lt;/p&gt;

&lt;p&gt;如果实例化对象的时候没有传入el属性。el会是一个空的div包裹着模版渲染出来的页面&lt;/p&gt;

&lt;p&gt;使用如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var view = Backbone.View.extend({
});

new view({
    el:&#39;body&#39;
})

或

var viewObj = new view({});
$(&quot;body&quot;).html(viewObj.$el);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两个方法都是把view对象实例化后渲染的插入到body中去&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/backbone%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/backbone%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</guid>
        
        <category>backbone</category>
        
        <category>view</category>
        
        <category>开发</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>移动web开发者常用调试方法</title>
        <description>&lt;p&gt;移动web前端开发者经常会需要解决ios和安卓平台的兼容问题(主要还是安卓,嗯,没错)&lt;/p&gt;

&lt;p&gt;如果不能连接真机调试的话,一些比较奇葩的样式或缓存问题就需要开发者有足够的经验才能定位到问题;但是如果&lt;/p&gt;

&lt;p&gt;能通过wifi或usb连接电脑直接调试,就相对容易定位到问题。(文章开头真难写)&lt;/p&gt;

&lt;p&gt;这里主要介绍几种调试方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ios + safari(mac)&lt;/li&gt;
  &lt;li&gt;android + chrome&lt;/li&gt;
  &lt;li&gt;微信调试&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iossafari-&quot;&gt;IOS+Safari 调试方法&lt;/h2&gt;
&lt;p&gt;iso＋safari，两个苹果的亲儿子
/Users/bingshu/CurtisCBS/_posts/2016-05-12-chrome插件开发.md
首先打开ios的 设置－safari－高级－web检查器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/ios-setting.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把如上图的设置好之后，使用usb链接mac&lt;/p&gt;

&lt;p&gt;打开电脑的safari&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/mac-safari.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;safari的菜单栏－开发 就能看到链接的手机以及当前手机打开的网页&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/safari-debug.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;*缺点：只有当ios的safari等少部分支持的浏览器中打开支持这种调试方法，如微信和应用内webview很多都&lt;/p&gt;

&lt;p&gt;不支持这样调试，不过本人比较常用这种方法&lt;/p&gt;

&lt;h2 id=&quot;android--chrome&quot;&gt;android + chrome&lt;/h2&gt;
&lt;p&gt;android(据说需要版本4.0以上)的调试方法首先需要将android机器设置到开发者模式&lt;/p&gt;

&lt;p&gt;方法：&lt;/p&gt;

&lt;p&gt;好像是 打开设置－关于本机－安卓版本号，然后连续点击七次（谁能解释一下为什么要点击七次吗？）&lt;/p&gt;

&lt;p&gt;然后返回上一界面，就应该能看到有个开发者模式&lt;/p&gt;

&lt;p&gt;点击进入，把usb调试的选项钩上&lt;/p&gt;

&lt;p&gt;然后链接usb到电脑&lt;/p&gt;

&lt;p&gt;电脑打开chrome浏览器&lt;/p&gt;

&lt;p&gt;在地址栏上输入 chrome://inspect/#devices&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/chrome-debug.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我手上也没有安卓真机，没法截图&lt;/p&gt;

&lt;p&gt;在安卓机上的浏览器打开网页，如上图就有手机当前打开网页的选项&lt;/p&gt;

&lt;p&gt;可以通过点击选项的inspect按钮，打开调试&lt;/p&gt;

&lt;p&gt;接下来的调试方法就和在chrome打开网页的调试方法一样了&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;微信调试&lt;/h2&gt;
&lt;p&gt;微信调试通过下载是微信官方提供给微信web开发者的调试应用来实现的&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html&quot;&gt;微信web开发者工具下载传送们&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/wx-download.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载之后打开应用,会需要开发者先扫描登录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/weixin-web-debug.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择平台（ios，android）之后，会有提示需要手机和电脑在同一内网，然后设置wifi的http代理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/wifi-http.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设置好后重新打开微信，在微信内打开需要调试的网页，可在调试工具的主界面看到出现了打开的网页&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/weixin-debugger.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击要调试的网页，即可进入调试模式&lt;/p&gt;

&lt;p&gt;*缺点：丑。还有样式调试也是相当难，给元素增改样式很麻烦&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2016 01:33:11 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</guid>
        
        <category>移动web</category>
        
        <category>调试</category>
        
        <category>微信</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>chrome插件开发</title>
        <description>&lt;p&gt;之前因为公司业务的需求，阉割了在web端的账号密码登录流程，只能通过发送短信验证码的方式来登录，尽管如此，原来老的登录接口还在。为了提高开发效率，特别是在测试环节，开发了一个chrome插件来继续使用老版的接口来实现用户的帐号密码登录&lt;/p&gt;

&lt;h2 id=&quot;chrome-extension&quot;&gt;开发chrome extension的需要知道的基本知识&lt;/h2&gt;
&lt;p&gt;chrome插件是主要用三部分构成&lt;/p&gt;

&lt;p&gt;*.浏览器地址栏右侧图标点击弹出的窗口页
*.运行在后台的脚本文件
*.嵌入到当前访问页的脚本文件&lt;/p&gt;

&lt;p&gt;三个部分可通过chrome对象方法进行通信&lt;/p&gt;

&lt;h2 id=&quot;mainfest&quot;&gt;mainfest配置文件&lt;/h2&gt;
&lt;p&gt;首先创建一个文件夹，用于存放当前插件，然后创建一个mainfest.json文件
该文件主要是像chrome浏览器解释该插件需要哪些依赖
…..算了，先不写了，好困，下次再写吧
..这篇比较长,先放着呢,嗯&lt;/p&gt;
</description>
        <pubDate>Thu, 12 May 2016 21:13:12 +0800</pubDate>
        <link>http://chenbingshu.com///2016/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid>
        
        <category>chrome插件</category>
        
        <category>开发</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>Performance Api在网页性能监测的使用和表现差异</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;为什么要做性能监测?&lt;/h2&gt;
&lt;p&gt;著名的谁说过一句话，如果连性能问题在哪里都不知道，如何做优化？所以，性能监测很明显是为了性能优化！&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance对象&lt;/h2&gt;
&lt;p&gt;html5提供了很多有利于前端攻城狮的webapi&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API&quot;&gt;(技术文档)&lt;/a&gt;
以下内容主要讲的是webapi的performace接口及相关使用&lt;/p&gt;

&lt;p&gt;在chrome控制台打印window.performance,可查看performance提供的api,如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150510/obj.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;memory&lt;/strong&gt;	提供了3个参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* jsHeapSizeLimit js内存使用大小限制
* totalJSHeapSize js总内存？？
* usedJSHeapSize  js已使用内存
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;navigation&lt;/strong&gt;对象提供了2个参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* redirectCount
* type
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;redirectCount表示到达当前页面的重定向次数&lt;/p&gt;

&lt;p&gt;type&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0:正常的url访问或点击跳转&lt;/li&gt;
  &lt;li&gt;1:刷新页面&lt;/li&gt;
  &lt;li&gt;2:通过历史纪录访问当前页面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;onresourcetimingbufferfull&lt;/strong&gt;属性是一个事件监听函数，当&lt;strong&gt;resourcetimingbufferfull&lt;/strong&gt;事件被触发的时候调用。而
&lt;strong&gt;resourcetimingbufferfull&lt;/strong&gt;是在浏览器资源缓冲区蛮的时候触发&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;performance.onresourcetimingbufferfull = function(){}; **timing** 对象提供了一组页面资源加载过程中的用时参数,也是网页性能监测主要要用到的api


* 	connectEnd:1462861568320
* 	connectStart:1462861568320
* 	domComplete:1462861569995
* 	domContentLoadedEventEnd:1462861569578
* 	domContentLoadedEventStart:1462861569528
* 	domInteractive:1462861569528
* 	domLoading:1462861568659
* 	domainLookupEnd:1462861568320
* 	domainLookupStart:1462861568320
* 	fetchStart:1462861568320
* 	loadEventEnd:1462861570046
* 	loadEventStart:1462861569995
* 	navigationStart:1462861567902
* 	redirectEnd:0
* 	redirectStart:0
* 	requestStart:1462861568322
* 	responseEnd:1462861569171
* 	responseStart:1462861568656
* 	secureConnectionStart:0
* 	unloadEventEnd:0
* 	unloadEventStart:0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下是来找磨叽啦（&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Performance&quot;&gt;mozilla&lt;/a&gt;）的一张关于这些参数的计时起止点:
&lt;img src=&quot;/images/post/20150510/illustration.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体资源的性能监测方法 getEntries():
通过该方法，可以获取到所有资源的加载用时等参数
var sourceEntries = window.performance.getEntries();
打印一下sourceEntries数组，可以获取到其成员包含以下属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;connectEnd:119.33500000000001
connectStart:119.33500000000001
domainLookupEnd:119.33500000000001
domainLookupStart:119.33500000000001
duration:106.41499999999999
entryType:&quot;resource&quot;
fetchStart:119.33500000000001
initiatorType:&quot;link&quot;
name:&quot;http://****/m/css/common_lib_****/less/common/***.css&quot;
redirectEnd:0
redirectStart:0
requestStart:206.28000000000003
responseEnd:225.75
responseStart:215.60000000000002
secureConnectionStart:0
startTime:119.33500000000001
workerStart:0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该方法能够获取到的资源有css,js,img,xmlhttprequest。这个方法基本能满足网页性能监测的要求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;打点方法:performance.now()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然，如果以上的timing对象提供的参数不能满足你的特殊监测要求，你还可以使用performance的now方法来定制时间监测点；
如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var startTime = performance.now();
&amp;lt;script src=&#39;http://*****.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
var endTime = performance.now();
var jsLoadTime = endTime - startTime; 可以大致统计到js资源加载的时间
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;浏览器支持&amp;amp;兼容&lt;/h2&gt;
    &lt;p&gt;&lt;img src=&quot;/images/post/20150510/support.png&quot; alt=&quot;image&quot; /&gt;
在用于项目中使用的时候，发现getEntries方法紧在chrome支持，用于移动端性能监测时候，getEntries也只能在安卓手机获取到资源的时间参数，具体的资源还是只能靠打点来实现。我有什么办法呢？没有。做到后面发现主要的群体ios不能监测到。。。。白做了！！！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 10 May 2016 18:10:11 +0800</pubDate>
        <link>http://chenbingshu.com///2016/performance_api%E5%9C%A8%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A1%A8%E7%8E%B0%E5%B7%AE%E5%BC%82/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/performance_api%E5%9C%A8%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A1%A8%E7%8E%B0%E5%B7%AE%E5%BC%82/</guid>
        
        <category>性能监测</category>
        
        <category>performance</category>
        
        <category>兼容</category>
        
        
        <category>前端</category>
        
      </item>
    
  </channel>
</rss>
