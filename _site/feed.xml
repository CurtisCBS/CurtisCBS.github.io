<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>THE ISLAND</title>
    <description>Curtis&#39;s Blog</description>
    <link>http://chenbingshu.com///</link>
    <atom:link href="http://chenbingshu.com///feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 29 Jul 2016 17:43:27 +0800</pubDate>
    <lastBuildDate>Fri, 29 Jul 2016 17:43:27 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>html文件直传到S3</title>
        <description>&lt;p&gt;主要实现:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;html文件拖拽上传

文件上传到aws.s3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;html&quot;&gt;html文件拖拽上传&lt;/h2&gt;

&lt;p&gt;drop是html5的新特性,详情看&lt;a href=&quot;http://www.w3school.com.cn/html5/html_5_draganddrop.asp&quot;&gt;W3SCHOOL介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以通过元素监听drop事件,获取到拖动到容器中的文件对象数组&lt;/p&gt;

&lt;p&gt;首先要先阻止document默认监听事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).on({
    dragleave:function(e){
        e.preventDefault();
    },
    drop:function(e){
        e.preventDefault();
    },
    dragenter:function(e){
        e.preventDefault();
    },
    dragover:function(e){
        e.preventDefault();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之后监听文件放置容器的drop事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var dragContainer = $(&quot;#dropContainer&quot;)[0];
 dragContainer.addEventListener(&quot;drop&quot;,function(e){
    e.preventDefault(); //取消默认浏览器拖拽效果
    var fileList = e.dataTransfer.files; //获取文件对象
	var ImageList = {};
	if(fileList.length == 0){
	    console.log(&#39;no file added!&#39;);
	    return false;
	}
	//file filter
	for(var i = 0 , j = 0 ; i &amp;lt; fileList.length ; i++ ){
	    if(fileList[i].type.indexOf(&#39;image&#39;) === -1){
	        delete fileList[i];
	    }
	    else{
	        ImageList[j++] = fileList[i];
	    }
	}

	for(var key in ImageList){
	    if(ImageList[key].size/1024 &amp;gt; that.getLimitSize()){
	        delete ImageList[key];
	    }
	    else{
		    that.appendUploadQueue(ImageList[key]);
	    }
	}
	// that.appendUploadQueue(ImageList);
	},false);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先同样是阻止默认事件的执行。&lt;/p&gt;

&lt;p&gt;通过event.dataTransfer.files可以获取到通过前端拖拽到容器的文件对象数组&lt;/p&gt;

&lt;p&gt;上面做了两个过滤,一个是文件类型非图片的过滤,一个是文件尺寸太大的过滤&lt;/p&gt;

&lt;p&gt;通过数据处理塞选可用的文件。&lt;/p&gt;

&lt;p&gt;appendUploadQueue是处理文件上传队列的方法&lt;/p&gt;

&lt;h2 id=&quot;awss3&quot;&gt;使用aws.s3需要了解的相关知识。&lt;/h2&gt;

&lt;p&gt;aws:Amazon Web Services&lt;/p&gt;

&lt;p&gt;s3:aws的一种,全称叫Simple Storage Service&lt;/p&gt;

&lt;p&gt;bucket:中文翻译叫存储桶。Amazon S3 存储桶名称在全球是唯一的（无论是在哪个 AWS 区域中创建存储桶）。在创建存储桶时指定名称。&lt;/p&gt;

&lt;p&gt;region:地区。我大中华地区只有一个节点(cn-north-1)。&lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/general/latest/gr/rande.html#s3_region&quot;&gt;节点列表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Access Key ID:相当于账号;&lt;/p&gt;

&lt;p&gt;Secret Access Key:相当于密码;&lt;/p&gt;

&lt;p&gt;key:很多地方都有key,大部分指的是文件名。。。。吧&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;常用于文件存储(应该是)&lt;/p&gt;

&lt;p&gt;html文件直传用的是aws提供的&lt;a href=&quot;http://docs.amazonaws.cn/en_us/AWSJavaScriptSDK/guide/browser-intro.html&quot;&gt;javascriptSDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先需要设置当前的账号密码,也就是上面提到的Access Key ID和Secret Access Key&lt;/p&gt;

&lt;p&gt;这里做了全局的配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    AWS.config.update({
		accessKeyId: that.ACCESS_KEY_ID,
		secretAccessKey: that.SECRECT_ACCESS_KEY
	});
	AWS.config.region = that.REGION;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是上面提到的appendUploadQueue方法的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   var params = {
	    Key: that.getFullStorePath() +&quot;/&quot;+that.getTimeString()+file.name,
	    ContentType: file.type,
	    Body: file,
	    ACL:&quot;public-read&quot;
	};
    (new AWS.S3({params: {Bucket: that.BUCKET}})).upload(params, function (err, originData) {
	    // results.innerHTML = err ? &#39;ERROR!&#39; : &#39;UPLOADED.&#39;;
		if(err){
			console.log(err);
			alert(&#39;上传出错&#39;);
		}
		else{
			if(that.settings.complete){
				var data = originData;
				data.Location = that.CDN_URL_PATH + data.Location.split(&quot;amazonaws.com.cn/&quot;)[1];
				that.settings.complete &amp;amp;&amp;amp; that.settings.complete(data);
        		that.appendThumbnail(data);
			}
		}
	});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是,文件同名是会覆盖掉之前的文件的,可以通过配置选项来实现可同名存在。&lt;/p&gt;

&lt;p&gt;上面是通过加了时间字符串来做到文件名的唯一性。&lt;/p&gt;

&lt;p&gt;Body是上传文件的主要内容。&lt;/p&gt;

&lt;p&gt;ACL是文件上传之后的权限。&lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/acl-overview.html&quot;&gt;这里是权限表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;*用户在请求上传成功返回资源的Location报xml access denied一般是acl未设置正确。&lt;/p&gt;

&lt;p&gt;*upload请求错误一般是s3服务器xml跨域未配置允许域和put请求&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jul 2016 16:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/html%E6%96%87%E4%BB%B6%E7%9B%B4%E4%BC%A0%E5%88%B0S3/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/html%E6%96%87%E4%BB%B6%E7%9B%B4%E4%BC%A0%E5%88%B0S3/</guid>
        
        <category>文件</category>
        
        <category>直传</category>
        
        <category>aws</category>
        
        <category>s3</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>如何在服务端运行node服务器来自动更新github代码</title>
        <description>&lt;p&gt;最近自己搭建了个VPS,主要用于存放一些项目。&lt;/p&gt;

&lt;p&gt;因为对服务端不太了解,所以学习比较吃力。&lt;/p&gt;

&lt;p&gt;而且每次push代码到github还得手动登陆服务器,拉取代码,然后重启服务。&lt;/p&gt;

&lt;p&gt;所以就在服务器端搭了个node服务器,弄个请求专门来监听github的代码提交纪录,并作服务器端的代码更新&lt;/p&gt;

&lt;h2 id=&quot;work-flow&quot;&gt;work flow&lt;/h2&gt;
&lt;p&gt;git本地代码提交(push) -&amp;gt; github webhook通知服务器 -&amp;gt; 服务器接收请求并执行代码更新(pull)&lt;/p&gt;

&lt;h2 id=&quot;github-webhook&quot;&gt;github webhook&lt;/h2&gt;

&lt;p&gt;github webhook是在你的仓库(repository)发生变动的时候,通知你的服务器,一个仓库&lt;/p&gt;

&lt;p&gt;可以设置多个webhook。在仓库的setting中可以设置(如下图)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160721/github-setting.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是我某个项目webhook的配置,需要注意的是,如果你起的服务不是默认端口,需要加上端口参数,否则会404报错,&lt;/p&gt;

&lt;p&gt;而且用于监听的这个请求接口(如图的listenGithubPush请求)需要是post,否则同样会报错。&lt;/p&gt;

&lt;p&gt;这边选项只选择了push事件才会通知服务端,根据需要也可以选择其他选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160721/webhook-config.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;服务器端监听通知&lt;/h2&gt;

&lt;p&gt;首先要在服务端上搭建一个node服务器,我是用express框架起了了一个服务器。&lt;/p&gt;

&lt;p&gt;创建坚挺服务器 githubListener.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var app = express();
var exec = require(&#39;exec&#39;);

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;);
});

app.post(&#39;/listenGithubPush&#39;,function(req,res){
  exec(&#39;git checkout master &amp;amp;&amp;amp; git pull&#39;,function(err, out, code) {
  if (err !== null) {
      console.log(&#39;exec error: &#39; + err);
    }
    process.stderr.write(err);
    process.stdout.write(out);
  // process.exit(code);
  });
  res.send(&#39;the server has redeployed!!&#39;);
});

var server = app.listen(3000, function () {
  var host = server.address().address;
  var port = server.address().port;
  console.log(&#39;Example app listening at http://%s:%s&#39;, host, port);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;exec用于通过让子进程执行某个命令(这里执行的是切换分支和拉取代码)&lt;/p&gt;

&lt;p&gt;这样,接下来只要在服务端运行该node服务就行了&lt;/p&gt;

&lt;h2 id=&quot;forever&quot;&gt;forever&lt;/h2&gt;

&lt;p&gt;如何让服务器一只运行node服务器?&lt;/p&gt;

&lt;p&gt;网上找到了两种方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.在后台创建进程,然后执行node

2.forever
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.nodejitsu.com/keep-a-nodejs-server-up-with-forever/&quot;&gt;Keep a node.js server up with Forever&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;只要在服务端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install forever -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就完成了forever的安装&lt;/p&gt;

&lt;p&gt;要启动node服务器只需要&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;forever start githubListener.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样,就可以在服务端让node服务器一值运行了&lt;/p&gt;

&lt;p&gt;最后,只要刚才设置了webhook的仓库push一下代码,就可以完成整个流程了&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Jul 2016 21:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E8%A1%8Cnode%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0github%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E8%A1%8Cnode%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0github%E4%BB%A3%E7%A0%81/</guid>
        
        <category>node</category>
        
        <category>github</category>
        
        <category>webhook</category>
        
        <category>forever</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>threejs实现webVR笔记</title>
        <description>&lt;p&gt;在2016年最火的15款HTML5游戏引擎排行榜中,threejs已经登顶了 &lt;a href=&quot;http://www.diycode.cc/topics/16&quot;&gt;排行榜&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看看threejs官网的各种炫酷demo知道为什么这么火了 &lt;a href=&quot;http://threejs.org/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近几天在看threejs,看着别人的教程,顺便依赖VRControl写了个&lt;a href=&quot;http://xurtis.com/webVR/index.html&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;threescene&quot;&gt;three.scene&lt;/h2&gt;

&lt;p&gt;使用threejs实现各种动画效果,主要是通过三个部分:场景,镜头,渲染器(难道这就是叫three的原因???)&lt;/p&gt;

&lt;p&gt;官方文档给出的例子&lt;/p&gt;

&lt;p&gt;创建场景:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码声明了threejs实现的三个部分,并添加到html的body中&lt;/p&gt;

&lt;p&gt;创建物体:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );

camera.position.z = 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;BoxGeometry是three创建一个立方体的方法&lt;/p&gt;

&lt;p&gt;MeshBasicMaterial是渲染材质,如颜色,材质的方法&lt;/p&gt;

&lt;p&gt;Mesh是将MeshBasicMaterial的材质渲染到BoxGeometry生成的立方体上,并被插入到scene中&lt;/p&gt;

&lt;p&gt;渲染:&lt;/p&gt;

&lt;p&gt;复制以上代码并不看到实际效果,因为并没有真正渲染&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function render() {
    requestAnimationFrame( render );
    renderer.render( scene, camera );
}
render();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的渲染方法,是个循环渲染。1s执行六十次渲染(60fps)&lt;/p&gt;

&lt;p&gt;旋转:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setInterval(function(){
	cube.rotation.x += 0.1;
	cube.rotation.y += 0.1;
},100);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改cube对象的rotation的值,会让渲染的立方体转动&lt;/p&gt;

&lt;p&gt;如同上面的修改camera.position.z的值一样,修改camera.position改变的是视图角度的位置&lt;/p&gt;

&lt;h2 id=&quot;matrix-transformations&quot;&gt;矩阵变换(Matrix transformations)&lt;/h2&gt;
&lt;p&gt;threejs使用矩阵来实现3D动画的变化.每个Object3D对象都有一个matrix,存储包含位置,旋转,缩放等数据&lt;/p&gt;

&lt;p&gt;实现3D变化的方法有两种:&lt;/p&gt;

&lt;p&gt;1.使用Object3D对象(以下简称O3D)的方法,如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var pos = {
    x:1,
    y:1,
    z:1
}
cube.position.copy(pos);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就实现了对象的位移&lt;/p&gt;

&lt;p&gt;O3D的matrixAutoUpdate默认为true,所以使用方法改变了matrix的值,就会立即渲染出效果;&lt;/p&gt;

&lt;p&gt;如果希望手动更新视图,只要把自动更新设为false,在需要重新渲染的时候调用O3D的updateMatrix方法就行了&lt;/p&gt;

&lt;p&gt;2.直接修改O3D的matrix&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var pos = {
    x:1,
    y:1,
    z:1
}
cube.matrixAutoUpdate = false;
cube.matrix.setPosition(start_position);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用这个方法进行变换时matrixAutoUpdate必须为false&lt;/p&gt;

&lt;p&gt;视角:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://threejs.org/docs/index.html#Reference/Math/Euler&quot;&gt;欧拉角(Euler angles)&lt;/a&gt; 和 &lt;a href=&quot;http://threejs.org/docs/index.html#Reference/Math/Quaternion&quot;&gt;四元数(Quaternions)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;threejs使用了如上两种听起来很高端听都没听过的方法来表示3d旋转&lt;/p&gt;

&lt;h2 id=&quot;texture&quot;&gt;材质(texture)&lt;/h2&gt;

&lt;p&gt;上面的例子创建了一个立方体,现在来实现材质渲染&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var loader = new THREE.TextureLoader();
loader.load(&#39;texture.png&#39;, textureLoad);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先创建一个加载器,在加载完图片后进行材质渲染&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function textureLoad(texture){
    texture.wrapS = THREE.RepeatWrapping;
	texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set( 1,1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果在本地调试或者跨域请求资源导致js error(Tainted canvases may not be loaded),可以参考如下方法解决&lt;a href=&quot;https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;windows&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;chrome –allow-file-access-from-files&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mac&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;open /Applications/Google\ Chrome.app –args –allow-file-access-from-files&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;vrcontrol&quot;&gt;VRControl&lt;/h2&gt;

&lt;p&gt;VRControls是threejs研发团队写的实现vr的依赖&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/cvan/three-vrcontrols&quot;&gt;github项目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中主要方法:gotVRDisplays&lt;/p&gt;

&lt;p&gt;获取vr设备(返回的设备可能有多个,该方法只取获取到的第一个),&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;navigator接口文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;获取成功回调返回了一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay&quot;&gt;vrdisplay对象&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过实时获取该对象的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRPose&quot;&gt;pose属性&lt;/a&gt;,如当前时间传感器传回的位置,方向等&lt;/p&gt;

&lt;p&gt;来进行requestAnimationFrame实时渲染并关联到camera。&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/threejs%E5%AE%9E%E7%8E%B0webVR%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/threejs%E5%AE%9E%E7%8E%B0webVR%E7%AC%94%E8%AE%B0/</guid>
        
        <category>webVR</category>
        
        <category>js</category>
        
        <category>threejs</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>推荐阅读</title>
        <description>&lt;p&gt;推荐阅读文章列表(时间排序) :&lt;/p&gt;

&lt;p&gt;7.29&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://isux.tencent.com/nine-question-of-swipe-html5-page.html&quot;&gt;滑屏 H5 开发实践九问&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.28&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codeceo.com/article/20-docs-guides-for-web-dev.html&quot;&gt;20个为前端开发者准备的文档和指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/choosing-an-http-status-code-stop-making-it-hard-8211-racksburg-904.html&quot;&gt;选择一个 HTTP 状态码不再是一件难事 – Racksburg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.26&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006063123&quot;&gt;你所不知道的 URL&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bupt-hjm.github.io/2016/07/10/boom/&quot;&gt;关于一个基于canvas的原生js图片爆炸插件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005989601&quot;&gt;聊一聊网页的分段传输与渲染那些事儿&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://efe.baidu.com/blog/composers-and-audiences/&quot;&gt;作曲家与听众&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://efe.baidu.com/blog/talk-about-sort-in-front-end/&quot;&gt;聊聊前端排序的那些事&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.25&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0ODA2ODU2NQ==&amp;amp;mid=2651129757&amp;amp;idx=1&amp;amp;sn=172a6a7dd481f83108bea46fc0283707#rd&quot;&gt;Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/vajoy/p/5341664.html&quot;&gt;浅谈浏览器http的缓存机制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxMzExMjYwOQ==&amp;amp;mid=2651890600&amp;amp;idx=1&amp;amp;sn=19b9ae0fc7d547a19914b90f1f04d479&amp;amp;key=8dcebf9e179c9f3a76c0e45d26aa4851e45437ef16d5cbbb8bdcc3598218e94dc0d4760809705abe987151c39d45f4c3&amp;amp;ascene=0&amp;amp;uin=MzAwODQwMzU1&amp;amp;devicetype=iMac+MacBookAir7%2C2+OSX+OSX+10.11.3+build(15D21)&amp;amp;version=11020201&amp;amp;pass_ticket=WVkWe6W2%2BC1v9xv%2FfxaVFLOLcTna2QKwRkTY7orOnfBEIwQ%2FyvU9kyfnmy5PcvBe&quot;&gt;我们是如何做好前端工程化和静态资源管理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.22&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hjxandhmr.github.io/2016/07/23/Android-ViewDispatchEvent/&quot;&gt;View的事件分发机制理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.21&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002797601&quot;&gt;nginx服务器安装及配置文件详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.20&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21650547&quot;&gt;通过一张简单的图，让你彻底地、永久地搞懂JS的==运算&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.19&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/front-end-development-in-an-internet-of-things-world-843.html&quot;&gt;物联网世界的前端开发&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://optimus.keycdn.com/support/webp-support/&quot;&gt;WebP Support – It’s More Than You Think&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDc0MTUxMw==&amp;amp;mid=2649639215&amp;amp;idx=1&amp;amp;sn=12b252e75aa3811c46c7fbf23cefd246&quot;&gt;程序员禅修十诫&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21556876&quot;&gt;移动应用开发者必须知道的Deep Linking技术&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.18&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://gold.xitu.io/post/5779d9bd6be3ff006a1ab5f4?utm_source=gold_browser_extension&quot;&gt;再长的视频一眼看完&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dvLden/Vidage&quot;&gt;solution to full-screen background video &amp;amp; image combined&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005987011&quot;&gt;前端JSer装逼手册&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/wonyun/p/5524617.html&quot;&gt;http协商缓存VS强缓存&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/35e20bb361d0#&quot;&gt;大公司里怎样开发和部署前端代码？(附实践方案)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.17&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/css/dirty-tricks-dark-corners-front-end-pt2.html&quot;&gt;前端开发中的一些黑魔法Pt2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.16&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://div.io/topic/1747&quot;&gt;给裸接口加一道防护，避免恶意盗刷和爬取&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://div.io/topic/981&quot;&gt;Meteor入门介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/619&quot;&gt;2016年JavaScript开发者需要了解的技能&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.15&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000606216&quot;&gt;React 的 diff 算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO/101-ways-to-make-your-website-more-awesome.md&quot;&gt;101 Ways to Make Your Website More Awesome&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21556998?refer=sayfe&quot;&gt;WebVR如此近 - three.js的WebVR示例程序解析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3ctech.com/topic/1836&quot;&gt;如何在前端开发中增加编码效率，这里有十款 Chrome 扩展可以帮你&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3ctech.com/topic/979&quot;&gt;MobileWeb 适配总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3ctech.com/topic/287&quot;&gt;在手机浏览器启动你的app&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.14&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2016/06/png-icon-change-color-by-css/&quot;&gt;PNG格式小图标的CSS任意颜色赋色技术&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/cht8687/You-Dont-Need-Lodash-Underscore?utm_campaign=CodeTengu&amp;amp;utm_medium=web&amp;amp;utm_source=CodeTengu_51&quot;&gt;You don’t (may not) need Lodash/Underscore Gitter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/css/dirty-tricks-dark-corners-front-end-pt1.html&quot;&gt;前端开发中的一些黑魔法Pt1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/foru17/front-end-collect&quot;&gt;前端收集&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/don-039-t-just-code-career-advice-from-the-programming-masters-javaworld-668.html&quot;&gt;来自于编程大师的职业建议：别老想着写码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.13&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/imweb/mobile&quot;&gt;移动开发经验汇总(冷门bug集合)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2016/05/h5-camera-literacy/&quot;&gt;H5视频直播扫盲&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2016/05/date-object/&quot;&gt;Date对象的那些事儿&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;amp;mid=504090077&amp;amp;idx=1&amp;amp;sn=a35b791e51286f7048c2155f7c888c6d#rd&quot;&gt;PC与无线齐飞，Web共Native一色——天猫首页全解密&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.12&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coolshell.cn/articles/17381.html&quot;&gt;性能测试应该怎么做？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/outsystems-experts/beyond-console-debugging-tricks-f7d0d7f5df4#.vwo17tm9f&quot;&gt;Beyond Console Debugging Tricks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2016/05/super-small-web-gesture-library-alloyfinger-released/&quot;&gt;alloyfinger手势库&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</guid>
        
        <category>推荐</category>
        
        <category>文章</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>如何在页面发送通知消息</title>
        <description>&lt;p&gt;如果你的网站需要在用户登陆或者在某些特定时刻向用户发送通知。&lt;/p&gt;

&lt;p&gt;这个webapi可能会起到效果&lt;/p&gt;

&lt;h2 id=&quot;notification&quot;&gt;Notification&lt;/h2&gt;

&lt;p&gt;Web Notifications API 使页面可以发出通知，通知将被显示在页面之外的系统层面上（通常使用操作系统的标准通知机制，但是在不同的平台和浏览器上的表现会有差异）。这个功能使  web 应用可以向用户发送信息，即使应用处于空闲状态。最明显的用例之一是一个网页版电子邮件应用程序，每当用户收到了一封新的电子邮件都需要通知用户，即使用户正在使用另一个应用程序。&lt;/p&gt;

&lt;p&gt;诸如在线团队协作平台(如tower)或者聊天系统,都需要主动向用户发送通知,让用户可以及时收到最新动态&lt;/p&gt;

&lt;p&gt;tower就是通过这个接口像用户发送通知消息的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;权限&lt;/h2&gt;

&lt;p&gt;使用Notification接口时需要像用户发送授权请求(如获取用户地址位置信息等需要用户隐私的接口都需要用户授权)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Notification.requestPermission( function(status) {

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;仅当status为granted时表示用户接受通知&lt;/p&gt;

&lt;p&gt;status有三种状态:default,granted,denied&lt;/p&gt;

&lt;p&gt;*default一般是用户未处理授权请求&lt;/p&gt;

&lt;p&gt;*granted表示用户接受通知的授权&lt;/p&gt;

&lt;p&gt;*denied表示用户拒绝接受通知&lt;/p&gt;

&lt;h2 id=&quot;notification-1&quot;&gt;Notification对象&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var notification = new Notification(title,{
    body:string,
    icon:imageUrl
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notification对象有三个参数,分别是通知标题,通知内容,还有图标&lt;/p&gt;

&lt;p&gt;显示效果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160701/notification.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;回调函数&lt;/h2&gt;

&lt;p&gt;notification有4个回调函数&lt;/p&gt;

&lt;p&gt;*onshow:当通知被显示给用户时触发。&lt;/p&gt;

&lt;p&gt;*onclick:当用户点击通知时触发。&lt;/p&gt;

&lt;p&gt;*onclose:当通知被关闭时触发。&lt;/p&gt;

&lt;p&gt;*onerror:当通知发生错误的时候触发。这通常是因为通知由于某些原因而无法显示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Notification.requestPermission( function(status) {

    var notification = new Notification(&quot;标题&quot;);

    notification.onshow = function(){};

    notification.onclick = function(){};

    notification.onclose = function(){};

    notification.onerror = function(){};

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/notification/Using_Web_Notifications&quot;&gt;接口文档&lt;/a&gt;);&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</guid>
        
        <category>通知</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>js节流throttle函数</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;节流函数&lt;/h2&gt;

&lt;p&gt;在前端页面,常出现用户频繁操作dom元素导致需要频繁更新视图或者发送请求。&lt;/p&gt;

&lt;p&gt;如果是后者的话,还可能会出现异步请求结果返回与发送时间的不顺序。&lt;/p&gt;

&lt;p&gt;常用于解决这种问题的一个方法就是通过节流函数,把用户短时间内的频繁操作进行累加,最后一次执行&lt;/p&gt;

&lt;p&gt;这样不仅提高性能而且更防止了上面提到的异步请求时间不同步的问题&lt;/p&gt;

&lt;p&gt;在前端实现节流函数一般是使用定时器实现&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最简单的节流函数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function throttle(){
    if(timer){
        clearTimer(timer)
    }
    timer = setTimeout(function(){},delay);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是最简单的节流函数。通过判断是否已经存在定时器,过滤掉用户之前的操作,直到delay计时完才进行函数执行&lt;/p&gt;

&lt;h2 id=&quot;underscorethrottle&quot;&gt;underscore的throttle&lt;/h2&gt;

&lt;p&gt;underscore是一个又好又快又小的库,快主要是因为他是采用函数式编程(来源于一位老师的话)&lt;/p&gt;

&lt;p&gt;underscore也听过了如上的throttle函数(&lt;a href=&quot;http://underscorejs.org/#throttle&quot;&gt;英文文档&lt;/a&gt;,&lt;a href=&quot;http://www.css88.com/doc/underscore/#throttle&quot;&gt;中文文档&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;来自官方的一个使用例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var throttled = _.throttle(updatePosition, 100);
$(window).scroll(throttled);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;window的resize和scroll都是会频繁触犯事件的。&lt;/p&gt;

&lt;p&gt;所以通过throttle函数加以过滤可以大大提高渲染性能&lt;/p&gt;

&lt;h2 id=&quot;vuedebounce&quot;&gt;vue的debounce&lt;/h2&gt;

&lt;p&gt;vue框架自带的input的debounce实现也是节流函数的一种。(&lt;a href=&quot;https://vuejs.org/guide/forms.html#debounce&quot;&gt;文档&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;并且对于点击等用户主动触发的事件同样可以通过设置debounce来实现。&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Jun 2016 18:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/js%E8%8A%82%E6%B5%81throttle%E5%87%BD%E6%95%B0/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/js%E8%8A%82%E6%B5%81throttle%E5%87%BD%E6%95%B0/</guid>
        
        <category>throttle</category>
        
        <category>节流</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>web scroll的滚动惯性</title>
        <description>&lt;p&gt;在上个公司的最后一个版本。( &lt;a href=&quot;http://ichuanyi.com/m/page/tomorrow_recommend/&quot;&gt;传送门&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;入口放在app的主页,所以对页面的动画效果和性能(流畅度)有较大的要求&lt;/p&gt;

&lt;p&gt;页面的在交互上做了较多动画,属于交互比较复杂的单页应用&lt;/p&gt;

&lt;p&gt;其中用户在点击顶部的”地址栏”,底部的”再推荐”,以及无推荐次数之后点击”再推荐” 这三部分弹出来的页面&lt;/p&gt;

&lt;p&gt;是显示在原本主要内容层级之上的,position值为fixed&lt;/p&gt;

&lt;p&gt;在提测时候发现在native内滚动这种长页面的时候,当用户手一离开屏幕时就会停止滚动&lt;/p&gt;

&lt;p&gt;该开始以为是用户的一系列touch事件在dom冒泡了。&lt;/p&gt;

&lt;p&gt;然后在滚动的元素容器设置了event.stopPropagation()事件阻止所有事件的冒泡&lt;/p&gt;

&lt;p&gt;发现并没有什么乱用&lt;/p&gt;

&lt;p&gt;最后在mozilla的开发者文档找到了-webkit-overflow-scrolling&lt;/p&gt;

&lt;p&gt;然后通过设置该属性值为touch竟然生效了!!!!!!!&lt;/p&gt;

&lt;p&gt;!!!!!&lt;/p&gt;

&lt;p&gt;mozilla对该属性是这么描述的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   The -webkit-overflow-scrolling CSS property controls whether or not touch devices use momentum-based scrolling for the given element.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该css属性控制是否滚动是基于动量的。。。这翻译听不下去了&lt;/p&gt;

&lt;p&gt;就是看你滚动是否是需要滚行吧!!这么翻译果然好多了&lt;/p&gt;

&lt;p&gt;该属性可设置两种值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto:设置为auto时,用户的手离开屏幕即停止滚动

touch:设置为touch时,用户手离开屏幕时会基于之前的动量递减(即保持一定的惯性)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-overflow-scrolling&quot;&gt;官方解释&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jun 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/webscroll%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%83%AF%E6%80%A7/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/webscroll%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%83%AF%E6%80%A7/</guid>
        
        <category>scroll</category>
        
        <category>惯性</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>backbone使用心得</title>
        <description>&lt;p&gt;从实习工作到现在已经一年多，公司web前端的客户端主要框架是backbone＋underscore＋artTemplate+jquery libs。经历了从混合着服务端语法到前端完全分离的开发模式。在项目重构中主要负责购物流程和订单这一块，虽然也意识到backbone这种mvc的短板。但是作为经典的前端mvc框架，还是很有必要学习了解一下&lt;/p&gt;

&lt;h2 id=&quot;backbone&quot;&gt;backbone简介&lt;/h2&gt;

&lt;p&gt;经典的前端mvc框架( &lt;a href=&quot;http://http://backbonejs.org/&quot;&gt;backbone官网&lt;/a&gt; , &lt;a href=&quot;http://www.css88.com/doc/backbone/&quot;&gt;中文文档&lt;/a&gt; ),主要给开发者提供了model，view，collection等结构，并提供丰富的事件机制及route功能&lt;/p&gt;

&lt;h2 id=&quot;model&quot;&gt;model&lt;/h2&gt;
&lt;p&gt;主要用于数据交互和业务逻辑处理，开发者一般是从backbone.model继承&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var model = Backbone.Model.extend({
	defaults:{
		name:&#39;curtis&#39;
	},
	initialize:function(){
		
	}
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就声明了一个从backbone.model继承的model变量，变量中的defaults是用于声明变量的一些默认属性，可以通过如下方法获取到默认属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var model1 = new model();
model1.get(&#39;name&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面会讲到model和view的结合使用&lt;/p&gt;

&lt;h2 id=&quot;modelgetset&quot;&gt;model的get和set方法&lt;/h2&gt;

&lt;p&gt;get：获取当前model某属性的值&lt;/p&gt;

&lt;p&gt;set：设置当前model某个属性的值，可以单个属性，也可以为一个json对象,设置了属性值之后会触发change事件，可通过设置view来监听model某属性来驱动视图进行更新&lt;/p&gt;

&lt;h2 id=&quot;initialize&quot;&gt;initialize&lt;/h2&gt;
&lt;p&gt;view对象的构造函数,即实例化对象的时候调用&lt;/p&gt;

&lt;h2 id=&quot;view&quot;&gt;view&lt;/h2&gt;

&lt;p&gt;于2016.06.29继续写了&lt;/p&gt;

&lt;p&gt;view是backbone的提供的视图结构,对于简单的单页应用来说(SPA)是最重要的部分;&lt;/p&gt;

&lt;p&gt;因为简单的单页应用其实并不需要通过control层来实现model和view的,两者之间增加一个control层&lt;/p&gt;

&lt;p&gt;反而使得框架接口变得复杂&lt;/p&gt;

&lt;h2 id=&quot;events&quot;&gt;events&lt;/h2&gt;

&lt;p&gt;events主要是绑定了当前模块试图的一些绑定事件,使用方法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var view = Backbone.View.extend({

  events: {
    &quot;click .testBtn&quot;:&quot;bindBtn&quot;
  },

  bindBtn:function(){
    //具体实现
  }

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;initialize-1&quot;&gt;initialize&lt;/h2&gt;
&lt;p&gt;view对象的构造函数,即实例化对象的时候调用&lt;/p&gt;

&lt;h2 id=&quot;el&quot;&gt;el&lt;/h2&gt;

&lt;p&gt;backboneView的一个重要属性,el是当前模块对应的dom元素,&lt;/p&gt;

&lt;p&gt;如果实例化对象的时候没有传入el属性。el会是一个空的div包裹着模版渲染出来的页面&lt;/p&gt;

&lt;p&gt;使用如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var view = Backbone.View.extend({
});

new view({
    el:&#39;body&#39;
})

或

var viewObj = new view({});
$(&quot;body&quot;).html(viewObj.$el);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两个方法都是把view对象实例化后渲染的插入到body中去&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/backbone%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/backbone%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</guid>
        
        <category>backbone</category>
        
        <category>view</category>
        
        <category>开发</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>移动web开发者常用调试方法</title>
        <description>&lt;p&gt;移动web前端开发者经常会需要解决ios和安卓平台的兼容问题(主要还是安卓,嗯,没错)&lt;/p&gt;

&lt;p&gt;如果不能连接真机调试的话,一些比较奇葩的样式或缓存问题就需要开发者有足够的经验才能定位到问题;但是如果&lt;/p&gt;

&lt;p&gt;能通过wifi或usb连接电脑直接调试,就相对容易定位到问题。(文章开头真难写)&lt;/p&gt;

&lt;p&gt;这里主要介绍几种调试方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ios + safari(mac)&lt;/li&gt;
  &lt;li&gt;android + chrome&lt;/li&gt;
  &lt;li&gt;微信调试&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iossafari-&quot;&gt;IOS+Safari 调试方法&lt;/h2&gt;
&lt;p&gt;iso＋safari，两个苹果的亲儿子
/Users/bingshu/CurtisCBS/_posts/2016-05-12-chrome插件开发.md
首先打开ios的 设置－safari－高级－web检查器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/ios-setting.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把如上图的设置好之后，使用usb链接mac&lt;/p&gt;

&lt;p&gt;打开电脑的safari&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/mac-safari.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;safari的菜单栏－开发 就能看到链接的手机以及当前手机打开的网页&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/safari-debug.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;*缺点：只有当ios的safari等少部分支持的浏览器中打开支持这种调试方法，如微信和应用内webview很多都&lt;/p&gt;

&lt;p&gt;不支持这样调试，不过本人比较常用这种方法&lt;/p&gt;

&lt;h2 id=&quot;android--chrome&quot;&gt;android + chrome&lt;/h2&gt;
&lt;p&gt;android(据说需要版本4.0以上)的调试方法首先需要将android机器设置到开发者模式&lt;/p&gt;

&lt;p&gt;方法：&lt;/p&gt;

&lt;p&gt;好像是 打开设置－关于本机－安卓版本号，然后连续点击七次（谁能解释一下为什么要点击七次吗？）&lt;/p&gt;

&lt;p&gt;然后返回上一界面，就应该能看到有个开发者模式&lt;/p&gt;

&lt;p&gt;点击进入，把usb调试的选项钩上&lt;/p&gt;

&lt;p&gt;然后链接usb到电脑&lt;/p&gt;

&lt;p&gt;电脑打开chrome浏览器&lt;/p&gt;

&lt;p&gt;在地址栏上输入 chrome://inspect/#devices&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/chrome-debug.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我手上也没有安卓真机，没法截图&lt;/p&gt;

&lt;p&gt;在安卓机上的浏览器打开网页，如上图就有手机当前打开网页的选项&lt;/p&gt;

&lt;p&gt;可以通过点击选项的inspect按钮，打开调试&lt;/p&gt;

&lt;p&gt;接下来的调试方法就和在chrome打开网页的调试方法一样了&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;微信调试&lt;/h2&gt;
&lt;p&gt;微信调试通过下载是微信官方提供给微信web开发者的调试应用来实现的&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html&quot;&gt;微信web开发者工具下载传送们&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/wx-download.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载之后打开应用,会需要开发者先扫描登录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/weixin-web-debug.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择平台（ios，android）之后，会有提示需要手机和电脑在同一内网，然后设置wifi的http代理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/wifi-http.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设置好后重新打开微信，在微信内打开需要调试的网页，可在调试工具的主界面看到出现了打开的网页&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20150529/weixin-debugger.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击要调试的网页，即可进入调试模式&lt;/p&gt;

&lt;p&gt;*缺点：丑。还有样式调试也是相当难，给元素增改样式很麻烦&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2016 01:33:11 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</guid>
        
        <category>移动web</category>
        
        <category>调试</category>
        
        <category>微信</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>chrome插件开发</title>
        <description>&lt;p&gt;之前因为公司业务的需求，阉割了在web端的账号密码登录流程，只能通过发送短信验证码的方式来登录，尽管如此，原来老的登录接口还在。为了提高开发效率，特别是在测试环节，开发了一个chrome插件来继续使用老版的接口来实现用户的帐号密码登录&lt;/p&gt;

&lt;h2 id=&quot;chrome-extension&quot;&gt;开发chrome extension的需要知道的基本知识&lt;/h2&gt;
&lt;p&gt;chrome插件是主要用三部分构成&lt;/p&gt;

&lt;p&gt;*.浏览器地址栏右侧图标点击弹出的窗口页
*.运行在后台的脚本文件
*.嵌入到当前访问页的脚本文件&lt;/p&gt;

&lt;p&gt;三个部分可通过chrome对象方法进行通信&lt;/p&gt;

&lt;h2 id=&quot;mainfest&quot;&gt;mainfest配置文件&lt;/h2&gt;
&lt;p&gt;首先创建一个文件夹，用于存放当前插件，然后创建一个mainfest.json文件
该文件主要是像chrome浏览器解释该插件需要哪些依赖
…..算了，先不写了，好困，下次再写吧
..这篇比较长,先放着呢,嗯&lt;/p&gt;
</description>
        <pubDate>Thu, 12 May 2016 21:13:12 +0800</pubDate>
        <link>http://chenbingshu.com///2016/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid>
        
        <category>chrome插件</category>
        
        <category>开发</category>
        
        
        <category>前端</category>
        
      </item>
    
  </channel>
</rss>
