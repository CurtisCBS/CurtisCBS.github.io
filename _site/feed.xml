<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>I&#39;m Curtis</title>
    <description>Curtis&#39;s Blog</description>
    <link>http://chenbingshu.com///</link>
    <atom:link href="http://chenbingshu.com///feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 30 Nov 2016 10:55:59 +0800</pubDate>
    <lastBuildDate>Wed, 30 Nov 2016 10:55:59 +0800</lastBuildDate>
    <generator>Jekyll v3.0.2</generator>
    
      <item>
        <title>firebase部署入门</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;一句话简介&lt;/h3&gt;

&lt;p&gt;Firebase 是一个移动平台，可以帮助您快速开发高品质应用，扩大用户群，并赚取更多收益。Firebase 由多种互补功能组成，您可以自行组合和匹配这些功能以满足自己的需求。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;新建项目&lt;/h3&gt;

&lt;p&gt;1.到firebase网站新建一个工程&lt;a href=&quot;https://console.firebase.google.com/?hl=zh-cn&quot;&gt;https://console.firebase.google.com/?hl=zh-cn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.创建完工程后在项目页面加入如下代码就可以将firebase加入到你的web应用了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;https://www.gstatic.com/firebasejs/3.6.1/firebase.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  // Initialize Firebase
  var config = {
    apiKey: &quot;api-key&quot;,
    authDomain: &quot;auth-domain&quot;,
    databaseURL: &quot;database-url&quot;,
    storageBucket: &quot;storage-bucket&quot;,
    messagingSenderId: &quot;messaging-sender-id&quot;
  };
  firebase.initializeApp(config);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;环境安装&lt;/h3&gt;

&lt;p&gt;1.确保计算机已经安装node环境 &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;node下载连接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.安装全局firebase-tools,需要全局安装是因为，只有全局安装了，才能使用对应的firebase命令行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g firebase-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.安装firebase-tools之后，需要授权登录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firebase login
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果遇到长时间的无响应，则通过一下命令行实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firebase login --no-localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在该命令行执行之后，会弹出google账号授权页面，此时页面需要代理（翻x墙），授权登陆后，会有一个授权码，复制之后，关闭网络代理，把授权码复制到终端，回车，搞定！&lt;/p&gt;

&lt;p&gt;成功显示如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20161129/auth-success.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.在自己的项目文件夹里执行初始化命令行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firebase init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20161129/firebase-init.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过space选择要初始化的类型。hosting用于部署静态资源，database用于实时数据库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;firebase init 命令不创建新目录。如果从头开始创建新项目，则应先创建目录，并在运行 init 命令之前更改项目目录。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5.部署firebase&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firebase deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;部署完就能通过终端上的URL进行访问&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Nov 2016 17:27:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/firebase%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/firebase%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/</guid>
        
        <category>firebase</category>
        
        <category>数据库</category>
        
        <category>教程</category>
        
        
        <category>数据库</category>
        
      </item>
    
      <item>
        <title>轻松在服务器搭建shadowsocks</title>
        <description>&lt;p&gt;对于码农，需要经常翻*墙查bug，看文档。如果自己去购买vpn服务，一年差不多也要一百来块。如果自己买个国外的服务器也贵不了多少。而且自己还能在服务器上搞点东西玩玩。对于大部分新手，bandwagon上的服务器还是比较便宜的。能满足大部分人的需求。最便宜只要3美刀一个月，一顿饭的钱。&lt;a href=&quot;https://bandwagonhost.com/aff.php?aff=9537&quot;&gt;bandwagon服务器购买链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;shadowsocks&quot;&gt;shadowsocks一句话简介&lt;/h3&gt;

&lt;p&gt;shadowsocks是开源socks5 proxy(以下简称ss),作者是个中国人&lt;a href=&quot;https://github.com/clowwindy&quot;&gt;clowwindy&lt;/a&gt; ，自己去网站购买服务的话，个人服务是16美刀&lt;a href=&quot;https://shadowsocks.com/&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;ss&quot;&gt;如何服务器上搭建一个ss服务器呢?&lt;/h3&gt;

&lt;p&gt;Debian/Ubuntu系统&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-pip python-m2crypto
sudo pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CentOS/RHEL系统&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo yum install m2crypto python-setuptools
sudo easy_install pip
sudo pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建一个ss的配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vi /home/ss.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把下面的内容拷贝到ss.json文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;服务器ip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;服务端口&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;local_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1080&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;密码&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;method&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aes-256-cfb&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中上面的服务器ip需要根据自己当前服务器的ip来设置，服务端口,密码可以随意设置，如果local_port在启动时报端口占用，可以改成其他未被占用的端口。method是加密编码方法,有如下“bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4”等，推荐上述的aes-256-cfb方法加密。&lt;/p&gt;

&lt;p&gt;启动服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ssserver -c /home/ss.json -d start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关闭服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ssserver -d stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ssserver -c /etc/shadowsocks.json -d restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;日志存放位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/var/log/shadowsocks.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行启动服务命令行后，一个ss服务就起好了&lt;/p&gt;

&lt;p&gt;接下来用户根据自己的操作系统下载对应的&lt;a href=&quot;https://shadowsocks.org/en/download/clients.html&quot;&gt;gui客户端&lt;/a&gt;,然后填入对应的参数就可以了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20161128/ss.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Nov 2016 16:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E8%BD%BB%E6%9D%BE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAshadowsocks/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E8%BD%BB%E6%9D%BE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAshadowsocks/</guid>
        
        <category>centos</category>
        
        <category>翻墙</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>初探自动捕获网页中的异常报错</title>
        <description>&lt;p&gt;由于当前国内测试行业的未技术化，特别是对前端测试的忽略，大多数公司的还是停留在以人力+人肉进行前端的测试，虽然大部分情况下可以暴露出大部分的问题，但是有一些网页的异常报错，测试人员并不会注意到或者没办法还原错误操作和环境等。所以，前端能够通过在自己项目代码里自动监听 -&amp;gt; 捕获 -&amp;gt; 记录 -&amp;gt; 存储到数据库。再通过创建dashboard获取异常数据，就可以实现云异常监控了。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;解决方案&lt;/h3&gt;

&lt;p&gt;实现异常的监控整体思路:&lt;/p&gt;

&lt;p&gt;通过监听异常，当未达到页面错误记录数时先记录错误日志（此处可以通过throttle函数来优化，防止当页面密集报错时候，频繁请求）。错误日志包含发生的日期，错误类型（runtime或resource）,UA(快速定位错误发生环境),referrer和url(了解用户的操作流程)。当达到错误日志上限或在一段时间内无监测到其他异常错误时候则向服务端发送请求记录该页面错误。&lt;/p&gt;

&lt;h3 id=&quot;javascript-&quot;&gt;javascript 运行时的异常报错监控&lt;/h3&gt;

&lt;p&gt;runtime error是比较严重的。对于同一段js代码，js报错常常会导致代码的中断且不会再向下执行。所以在测试环境中，大部分的runtime error是会被&lt;/p&gt;

&lt;p&gt;暴露出来的，否则可能会导致整个页面的流程无法进行。但是由于纯人力+人肉的测试，难免有特殊的环境会导致运行的错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onerror

window.onerror = function(messageOrEvent, source, lineno, colno, error)

{ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;window.onerror是js运行时错误的一个监听处理函数,当js的语法错误或程序中抛出异常时触发，触发时候会返回一个errorEvent对象。对象包含错误信息，错误的目标来源，行数，列数及错误对象(对象包含堆栈信息)&lt;/p&gt;

&lt;h3 id=&quot;document-&quot;&gt;document 资源加载错误的监控&lt;/h3&gt;

&lt;p&gt;页面资源加载失败，是测试环境比较难测试出来的，往往资源加载失败是因为用户网络问题或服务端或cdn服务商的服务问题等。这种问题的环境相对比较难以还原。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target.addEventListener(type, listener[, options]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过对window.addEventListener(‘error’, handler, true)的监听，可以监听到包含运行时错误及资源加载失败的错误,所以当对两者同时使用时，需要过滤掉运行时错误避免重复记录可以通过下面的方式过滤掉运行时错误&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;handler = function(err){
    if(err.target !== window){
      //过滤掉window的运行时错误
    }
}

err.target.nodeName可以获取到未加载成功的资源的节点名字;
err.target.src可以记录未加载成功资源的资源路径
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;vue&quot;&gt;黑科技—针对vue报错的监控&lt;/h3&gt;

&lt;p&gt;因为当前业务基于vue，但由于vue的内部机制，并不能通过以上两种方法获取到它抛出的异常。下面教大家使用黑科技—通过重写console.error方法来达到记录错误日志。&lt;/p&gt;

&lt;p&gt;console.error = (function(origin){
    return function(errorlog)
    {
      handler();//基于业务的日志记录及数据报错
      origin.call(console,errorlog);
    }
  })(console.error);&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;兼容&amp;amp;常见问题&lt;/h3&gt;

&lt;h4 id=&quot;script-error-&quot;&gt;Script error. 无法记录到异常信息&lt;/h4&gt;

&lt;p&gt;1.当页面的js来自cdn，在chrome和firefox无法捕捉到异常信息&lt;/p&gt;

&lt;p&gt;2.跨域，在cdn服务器上设置Access-Control-Allow-Origin可能会起效&lt;/p&gt;

&lt;p&gt;3.通过设置该属性可能可以解决&lt;script crossorigin=&quot;anonymous&quot; src=&quot;xx.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://danlimerick.wordpress.com/2014/01/18/how-to-catch-javascript-errors-with-window-onerror-even-on-chrome-and-firefox/&quot;&gt;相关问题链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/CurtisCBS/monitor&quot;&gt;Github项目链接&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Nov 2016 16:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E5%88%9D%E6%8E%A2%E8%87%AA%E5%8A%A8%E6%8D%95%E8%8E%B7%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8A%A5%E9%94%99/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E5%88%9D%E6%8E%A2%E8%87%AA%E5%8A%A8%E6%8D%95%E8%8E%B7%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8A%A5%E9%94%99/</guid>
        
        <category>监测</category>
        
        <category>自动化</category>
        
        <category>异常</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>html文件直传到S3</title>
        <description>&lt;p&gt;主要实现:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;html文件拖拽上传

文件上传到aws.s3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;html&quot;&gt;html文件拖拽上传&lt;/h3&gt;

&lt;p&gt;drop是html5的新特性,详情看&lt;a href=&quot;http://www.w3school.com.cn/html5/html_5_draganddrop.asp&quot;&gt;W3SCHOOL介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以通过元素监听drop事件,获取到拖动到容器中的文件对象数组&lt;/p&gt;

&lt;p&gt;首先要先阻止document默认监听事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).on({
    dragleave:function(e){
        e.preventDefault();
    },
    drop:function(e){
        e.preventDefault();
    },
    dragenter:function(e){
        e.preventDefault();
    },
    dragover:function(e){
        e.preventDefault();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之后监听文件放置容器的drop事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var dragContainer = $(&quot;#dropContainer&quot;)[0];
 dragContainer.addEventListener(&quot;drop&quot;,function(e){
    e.preventDefault(); //取消默认浏览器拖拽效果
    var fileList = e.dataTransfer.files; //获取文件对象
	var ImageList = {};
	if(fileList.length == 0){
	    console.log(&#39;no file added!&#39;);
	    return false;
	}
	//file filter
	for(var i = 0 , j = 0 ; i &amp;lt; fileList.length ; i++ ){
	    if(fileList[i].type.indexOf(&#39;image&#39;) === -1){
	        delete fileList[i];
	    }
	    else{
	        ImageList[j++] = fileList[i];
	    }
	}

	for(var key in ImageList){
	    if(ImageList[key].size/1024 &amp;gt; that.getLimitSize()){
	        delete ImageList[key];
	    }
	    else{
		    that.appendUploadQueue(ImageList[key]);
	    }
	}
	// that.appendUploadQueue(ImageList);
	},false);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先同样是阻止默认事件的执行。&lt;/p&gt;

&lt;p&gt;通过event.dataTransfer.files可以获取到通过前端拖拽到容器的文件对象数组&lt;/p&gt;

&lt;p&gt;上面做了两个过滤,一个是文件类型非图片的过滤,一个是文件尺寸太大的过滤&lt;/p&gt;

&lt;p&gt;通过数据处理塞选可用的文件。&lt;/p&gt;

&lt;p&gt;appendUploadQueue是处理文件上传队列的方法&lt;/p&gt;

&lt;h3 id=&quot;awss3&quot;&gt;使用aws.s3需要了解的相关知识。&lt;/h3&gt;

&lt;p&gt;aws:Amazon Web Services&lt;/p&gt;

&lt;p&gt;s3:aws的一种,全称叫Simple Storage Service&lt;/p&gt;

&lt;p&gt;bucket:中文翻译叫存储桶。Amazon S3 存储桶名称在全球是唯一的（无论是在哪个 AWS 区域中创建存储桶）。在创建存储桶时指定名称。&lt;/p&gt;

&lt;p&gt;region:地区。我大中华地区只有一个节点(cn-north-1)。&lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/general/latest/gr/rande.html#s3_region&quot;&gt;节点列表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Access Key ID:相当于账号;&lt;/p&gt;

&lt;p&gt;Secret Access Key:相当于密码;&lt;/p&gt;

&lt;p&gt;key:很多地方都有key,大部分指的是文件名。。。。吧&lt;/p&gt;

&lt;p&gt;常用于文件存储(应该是)&lt;/p&gt;

&lt;p&gt;html文件直传用的是aws提供的&lt;a href=&quot;http://docs.amazonaws.cn/en_us/AWSJavaScriptSDK/guide/browser-intro.html&quot;&gt;javascriptSDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先需要设置当前的账号密码,也就是上面提到的Access Key ID和Secret Access Key&lt;/p&gt;

&lt;p&gt;这里做了全局的配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    AWS.config.update({
		accessKeyId: that.ACCESS_KEY_ID,
		secretAccessKey: that.SECRECT_ACCESS_KEY
	});
	AWS.config.region = that.REGION;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是上面提到的appendUploadQueue方法的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   var params = {
	    Key: that.getFullStorePath() +&quot;/&quot;+that.getTimeString()+file.name,
	    ContentType: file.type,
	    Body: file,
	    ACL:&quot;public-read&quot;
	};
    (new AWS.S3({params: {Bucket: that.BUCKET}})).upload(params, function (err, originData) {
	    // results.innerHTML = err ? &#39;ERROR!&#39; : &#39;UPLOADED.&#39;;
		if(err){
			console.log(err);
			alert(&#39;上传出错&#39;);
		}
		else{
			if(that.settings.complete){
				var data = originData;
				data.Location = that.CDN_URL_PATH + data.Location.split(&quot;amazonaws.com.cn/&quot;)[1];
				that.settings.complete &amp;amp;&amp;amp; that.settings.complete(data);
        		that.appendThumbnail(data);
			}
		}
	});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是,文件同名是会覆盖掉之前的文件的,可以通过配置选项来实现可同名存在。&lt;/p&gt;

&lt;p&gt;上面是通过加了时间字符串来做到文件名的唯一性。&lt;/p&gt;

&lt;p&gt;Body是上传文件的主要内容。&lt;/p&gt;

&lt;p&gt;ACL是文件上传之后的权限。&lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/acl-overview.html&quot;&gt;这里是权限表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;*用户在请求上传成功返回资源的Location报xml access denied一般是acl未设置正确。&lt;/p&gt;

&lt;p&gt;*upload请求错误一般是s3服务器xml跨域未配置允许域和put请求&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jul 2016 16:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/html%E6%96%87%E4%BB%B6%E7%9B%B4%E4%BC%A0%E5%88%B0S3/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/html%E6%96%87%E4%BB%B6%E7%9B%B4%E4%BC%A0%E5%88%B0S3/</guid>
        
        <category>文件</category>
        
        <category>直传</category>
        
        <category>aws</category>
        
        <category>s3</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>如何在服务端运行node服务器来自动更新github代码</title>
        <description>&lt;p&gt;最近自己搭建了个VPS,主要用于存放一些项目。&lt;/p&gt;

&lt;p&gt;因为对服务端不太了解,所以学习比较吃力。&lt;/p&gt;

&lt;p&gt;而且每次push代码到github还得手动登陆服务器,拉取代码,然后重启服务。&lt;/p&gt;

&lt;p&gt;所以就在服务器端搭了个node服务器,弄个请求专门来监听github的代码提交纪录,并作服务器端的代码更新&lt;/p&gt;

&lt;h3 id=&quot;work-flow&quot;&gt;work flow&lt;/h3&gt;

&lt;p&gt;git本地代码提交(push) -&amp;gt; github webhook通知服务器 -&amp;gt; 服务器接收请求并执行代码更新(pull)&lt;/p&gt;

&lt;h3 id=&quot;github-webhook&quot;&gt;github webhook&lt;/h3&gt;

&lt;p&gt;github webhook是在你的仓库(repository)发生变动的时候,通知你的服务器,一个仓库&lt;/p&gt;

&lt;p&gt;可以设置多个webhook。在仓库的setting中可以设置(如下图)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160721/github-setting.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是我某个项目webhook的配置,需要注意的是,如果你起的服务不是默认端口,需要加上端口参数,否则会404报错,&lt;/p&gt;

&lt;p&gt;而且用于监听的这个请求接口(如图的listenGithubPush请求)需要是post,否则同样会报错。&lt;/p&gt;

&lt;p&gt;这边选项只选择了push事件才会通知服务端,根据需要也可以选择其他选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160721/webhook-config.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;服务器端监听通知&lt;/h3&gt;

&lt;p&gt;首先要在服务端上搭建一个node服务器,我是用express框架起了了一个服务器。&lt;/p&gt;

&lt;p&gt;创建坚挺服务器 githubListener.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var app = express();
var exec = require(&#39;exec&#39;);

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;);
});

app.post(&#39;/listenGithubPush&#39;,function(req,res){
  exec(&#39;git checkout master &amp;amp;&amp;amp; git pull&#39;,function(err, out, code) {
  if (err !== null) {
      console.log(&#39;exec error: &#39; + err);
    }
    process.stderr.write(err);
    process.stdout.write(out);
  // process.exit(code);
  });
  res.send(&#39;the server has redeployed!!&#39;);
});

var server = app.listen(3000, function () {
  var host = server.address().address;
  var port = server.address().port;
  console.log(&#39;Example app listening at http://%s:%s&#39;, host, port);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;exec用于通过让子进程执行某个命令(这里执行的是切换分支和拉取代码)&lt;/p&gt;

&lt;p&gt;这样,接下来只要在服务端运行该node服务就行了&lt;/p&gt;

&lt;h3 id=&quot;forever&quot;&gt;forever&lt;/h3&gt;

&lt;p&gt;如何让服务器一只运行node服务器?&lt;/p&gt;

&lt;p&gt;网上找到了两种方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.在后台创建进程,然后执行node

2.forever
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.nodejitsu.com/keep-a-nodejs-server-up-with-forever/&quot;&gt;Keep a node.js server up with Forever&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;只要在服务端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install forever -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就完成了forever的安装&lt;/p&gt;

&lt;p&gt;要启动node服务器只需要&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;forever start githubListener.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样,就可以在服务端让node服务器一值运行了&lt;/p&gt;

&lt;p&gt;最后,只要刚才设置了webhook的仓库push一下代码,就可以完成整个流程了&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Jul 2016 21:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E8%A1%8Cnode%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0github%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E8%A1%8Cnode%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0github%E4%BB%A3%E7%A0%81/</guid>
        
        <category>node</category>
        
        <category>github</category>
        
        <category>webhook</category>
        
        <category>forever</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>threejs实现webVR笔记</title>
        <description>&lt;p&gt;在2016年最火的15款HTML5游戏引擎排行榜中,threejs已经登顶了 &lt;a href=&quot;http://www.diycode.cc/topics/16&quot;&gt;排行榜&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看看threejs官网的各种炫酷demo知道为什么这么火了 &lt;a href=&quot;http://threejs.org/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近几天在看threejs,看着别人的教程,顺便依赖VRControl写了个&lt;a href=&quot;http://xurtis.com/webVR/index.html&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;threescene&quot;&gt;three.scene&lt;/h3&gt;

&lt;p&gt;使用threejs实现各种动画效果,主要是通过三个部分:场景,镜头,渲染器(难道这就是叫three的原因???)&lt;/p&gt;

&lt;p&gt;官方文档给出的例子&lt;/p&gt;

&lt;p&gt;创建场景:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码声明了threejs实现的三个部分,并添加到html的body中&lt;/p&gt;

&lt;p&gt;创建物体:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );

camera.position.z = 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;BoxGeometry是three创建一个立方体的方法&lt;/p&gt;

&lt;p&gt;MeshBasicMaterial是渲染材质,如颜色,材质的方法&lt;/p&gt;

&lt;p&gt;Mesh是将MeshBasicMaterial的材质渲染到BoxGeometry生成的立方体上,并被插入到scene中&lt;/p&gt;

&lt;p&gt;渲染:&lt;/p&gt;

&lt;p&gt;复制以上代码并不看到实际效果,因为并没有真正渲染&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function render() {
    requestAnimationFrame( render );
    renderer.render( scene, camera );
}
render();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的渲染方法,是个循环渲染。1s执行六十次渲染(60fps)&lt;/p&gt;

&lt;p&gt;旋转:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setInterval(function(){
	cube.rotation.x += 0.1;
	cube.rotation.y += 0.1;
},100);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改cube对象的rotation的值,会让渲染的立方体转动&lt;/p&gt;

&lt;p&gt;如同上面的修改camera.position.z的值一样,修改camera.position改变的是视图角度的位置&lt;/p&gt;

&lt;h3 id=&quot;matrix-transformations&quot;&gt;矩阵变换(Matrix transformations)&lt;/h3&gt;

&lt;p&gt;threejs使用矩阵来实现3D动画的变化.每个Object3D对象都有一个matrix,存储包含位置,旋转,缩放等数据&lt;/p&gt;

&lt;p&gt;实现3D变化的方法有两种:&lt;/p&gt;

&lt;p&gt;1.使用Object3D对象(以下简称O3D)的方法,如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var pos = {
    x:1,
    y:1,
    z:1
}
cube.position.copy(pos);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就实现了对象的位移&lt;/p&gt;

&lt;p&gt;O3D的matrixAutoUpdate默认为true,所以使用方法改变了matrix的值,就会立即渲染出效果;&lt;/p&gt;

&lt;p&gt;如果希望手动更新视图,只要把自动更新设为false,在需要重新渲染的时候调用O3D的updateMatrix方法就行了&lt;/p&gt;

&lt;p&gt;2.直接修改O3D的matrix&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var pos = {
    x:1,
    y:1,
    z:1
}
cube.matrixAutoUpdate = false;
cube.matrix.setPosition(start_position);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用这个方法进行变换时matrixAutoUpdate必须为false&lt;/p&gt;

&lt;p&gt;视角:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://threejs.org/docs/index.html#Reference/Math/Euler&quot;&gt;欧拉角(Euler angles)&lt;/a&gt; 和 &lt;a href=&quot;http://threejs.org/docs/index.html#Reference/Math/Quaternion&quot;&gt;四元数(Quaternions)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;threejs使用了如上两种听起来很高端听都没听过的方法来表示3d旋转&lt;/p&gt;

&lt;h3 id=&quot;texture&quot;&gt;材质(texture)&lt;/h3&gt;

&lt;p&gt;上面的例子创建了一个立方体,现在来实现材质渲染&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var loader = new THREE.TextureLoader();
loader.load(&#39;texture.png&#39;, textureLoad);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先创建一个加载器,在加载完图片后进行材质渲染&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function textureLoad(texture){
    texture.wrapS = THREE.RepeatWrapping;
	texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set( 1,1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果在本地调试或者跨域请求资源导致js error(Tainted canvases may not be loaded),可以参考如下方法解决&lt;a href=&quot;https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;windows&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;chrome –allow-file-access-from-files&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mac&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;open /Applications/Google\ Chrome.app –args –allow-file-access-from-files&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;vrcontrol&quot;&gt;VRControl&lt;/h3&gt;

&lt;p&gt;VRControls是threejs研发团队写的实现vr的依赖&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/cvan/three-vrcontrols&quot;&gt;github项目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中主要方法:gotVRDisplays&lt;/p&gt;

&lt;p&gt;获取vr设备(返回的设备可能有多个,该方法只取获取到的第一个),&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;navigator接口文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;获取成功回调返回了一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay&quot;&gt;vrdisplay对象&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过实时获取该对象的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRPose&quot;&gt;pose属性&lt;/a&gt;,如当前时间传感器传回的位置,方向等&lt;/p&gt;

&lt;p&gt;来进行requestAnimationFrame实时渲染并关联到camera。&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/threejs%E5%AE%9E%E7%8E%B0webVR%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/threejs%E5%AE%9E%E7%8E%B0webVR%E7%AC%94%E8%AE%B0/</guid>
        
        <category>webVR</category>
        
        <category>js</category>
        
        <category>threejs</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>推荐阅读</title>
        <description>&lt;p&gt;推荐阅读文章列表(时间排序) :&lt;/p&gt;

&lt;p&gt;9.26&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006990480&quot;&gt;端模板的原理与实现&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9.18&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/javascript-sdk-design-guide-530.html&quot;&gt;JavaScript SDK设计指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://gold.xitu.io/post/57dcd394a22b9d00610c5ec8?utm_source=gold_browser_extension&quot;&gt;十大经典算法总结（JavaScript描述）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9.14&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jackpu.com/qian-duan-shen-qi-adobe-brackets-shi-yong-xin-de/&quot;&gt;前端神器 Adobe Brackets 使用心得&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006897488&quot;&gt;SphinxJS——把字符串加密成png图片的超轻量级开源库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9.8&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22266609&quot;&gt;技术团队风格指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9.7&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006808445&quot;&gt;js的沙箱内容&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.24&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://luckykun.com/work/2016-08-16/file-upload.html&quot;&gt;两种文件上传的实现－Ajax上传和form+iframe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rccoder/blog/issues/12&quot;&gt;说说浏览器端缓存的那点事儿-扑朔迷离的 etag 与 last-modified&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.9&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/d857c3ff78d6&quot;&gt;如何让你的网页打开速度降低到1s内&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.4&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006129337&quot;&gt;javascript中那些折磨人的面试题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coolshell.cn/articles/17416.html&quot;&gt;缓存更新的套路&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/67820/&quot;&gt;18 个锻炼编程技能的网站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.3&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006140042&quot;&gt;移动端H5图片上传的那些坑&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006150186&quot;&gt;在JavaScript中，如何判断数组是数组?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://qianduan.guru/2016/07/26/The-Languages-Which-Almost-Became-CSS/&quot;&gt;扒一扒 CSS 语言的诞生史&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.1&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://imweb.io/topic/55e32fd5771670e207a16bb9&quot;&gt;前端如何呼风唤雨&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.xuebuyuan.com/2129104.html&quot;&gt;Chrome浏览器中的JavaScript多线程—WebWorker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.29&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://isux.tencent.com/nine-question-of-swipe-html5-page.html&quot;&gt;滑屏 H5 开发实践九问&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.28&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codeceo.com/article/20-docs-guides-for-web-dev.html&quot;&gt;20个为前端开发者准备的文档和指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/choosing-an-http-status-code-stop-making-it-hard-8211-racksburg-904.html&quot;&gt;选择一个 HTTP 状态码不再是一件难事 – Racksburg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.26&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006063123&quot;&gt;你所不知道的 URL&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bupt-hjm.github.io/2016/07/10/boom/&quot;&gt;关于一个基于canvas的原生js图片爆炸插件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005989601&quot;&gt;聊一聊网页的分段传输与渲染那些事儿&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://efe.baidu.com/blog/composers-and-audiences/&quot;&gt;作曲家与听众&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://efe.baidu.com/blog/talk-about-sort-in-front-end/&quot;&gt;聊聊前端排序的那些事&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.25&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0ODA2ODU2NQ==&amp;amp;mid=2651129757&amp;amp;idx=1&amp;amp;sn=172a6a7dd481f83108bea46fc0283707#rd&quot;&gt;Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/vajoy/p/5341664.html&quot;&gt;浅谈浏览器http的缓存机制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxMzExMjYwOQ==&amp;amp;mid=2651890600&amp;amp;idx=1&amp;amp;sn=19b9ae0fc7d547a19914b90f1f04d479&amp;amp;key=8dcebf9e179c9f3a76c0e45d26aa4851e45437ef16d5cbbb8bdcc3598218e94dc0d4760809705abe987151c39d45f4c3&amp;amp;ascene=0&amp;amp;uin=MzAwODQwMzU1&amp;amp;devicetype=iMac+MacBookAir7%2C2+OSX+OSX+10.11.3+build(15D21)&amp;amp;version=11020201&amp;amp;pass_ticket=WVkWe6W2%2BC1v9xv%2FfxaVFLOLcTna2QKwRkTY7orOnfBEIwQ%2FyvU9kyfnmy5PcvBe&quot;&gt;我们是如何做好前端工程化和静态资源管理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.22&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hjxandhmr.github.io/2016/07/23/Android-ViewDispatchEvent/&quot;&gt;View的事件分发机制理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.21&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002797601&quot;&gt;nginx服务器安装及配置文件详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.20&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21650547&quot;&gt;通过一张简单的图，让你彻底地、永久地搞懂JS的==运算&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.19&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/front-end-development-in-an-internet-of-things-world-843.html&quot;&gt;物联网世界的前端开发&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://optimus.keycdn.com/support/webp-support/&quot;&gt;WebP Support – It’s More Than You Think&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDc0MTUxMw==&amp;amp;mid=2649639215&amp;amp;idx=1&amp;amp;sn=12b252e75aa3811c46c7fbf23cefd246&quot;&gt;程序员禅修十诫&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21556876&quot;&gt;移动应用开发者必须知道的Deep Linking技术&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.18&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://gold.xitu.io/post/5779d9bd6be3ff006a1ab5f4?utm_source=gold_browser_extension&quot;&gt;再长的视频一眼看完&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dvLden/Vidage&quot;&gt;solution to full-screen background video &amp;amp; image combined&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005987011&quot;&gt;前端JSer装逼手册&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/wonyun/p/5524617.html&quot;&gt;http协商缓存VS强缓存&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/35e20bb361d0#&quot;&gt;大公司里怎样开发和部署前端代码？(附实践方案)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.17&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/css/dirty-tricks-dark-corners-front-end-pt2.html&quot;&gt;前端开发中的一些黑魔法Pt2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.16&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://div.io/topic/1747&quot;&gt;给裸接口加一道防护，避免恶意盗刷和爬取&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://div.io/topic/981&quot;&gt;Meteor入门介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/619&quot;&gt;2016年JavaScript开发者需要了解的技能&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.15&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000606216&quot;&gt;React 的 diff 算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO/101-ways-to-make-your-website-more-awesome.md&quot;&gt;101 Ways to Make Your Website More Awesome&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21556998?refer=sayfe&quot;&gt;WebVR如此近 - three.js的WebVR示例程序解析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3ctech.com/topic/1836&quot;&gt;如何在前端开发中增加编码效率，这里有十款 Chrome 扩展可以帮你&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3ctech.com/topic/979&quot;&gt;MobileWeb 适配总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3ctech.com/topic/287&quot;&gt;在手机浏览器启动你的app&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.14&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2016/06/png-icon-change-color-by-css/&quot;&gt;PNG格式小图标的CSS任意颜色赋色技术&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/cht8687/You-Dont-Need-Lodash-Underscore?utm_campaign=CodeTengu&amp;amp;utm_medium=web&amp;amp;utm_source=CodeTengu_51&quot;&gt;You don’t (may not) need Lodash/Underscore Gitter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/css/dirty-tricks-dark-corners-front-end-pt1.html&quot;&gt;前端开发中的一些黑魔法Pt1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/foru17/front-end-collect&quot;&gt;前端收集&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zcfy.cc/article/don-039-t-just-code-career-advice-from-the-programming-masters-javaworld-668.html&quot;&gt;来自于编程大师的职业建议：别老想着写码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.13&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/imweb/mobile&quot;&gt;移动开发经验汇总(冷门bug集合)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2016/05/h5-camera-literacy/&quot;&gt;H5视频直播扫盲&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2016/05/date-object/&quot;&gt;Date对象的那些事儿&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;amp;mid=504090077&amp;amp;idx=1&amp;amp;sn=a35b791e51286f7048c2155f7c888c6d#rd&quot;&gt;PC与无线齐飞，Web共Native一色——天猫首页全解密&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.12&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coolshell.cn/articles/17381.html&quot;&gt;性能测试应该怎么做？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/outsystems-experts/beyond-console-debugging-tricks-f7d0d7f5df4#.vwo17tm9f&quot;&gt;Beyond Console Debugging Tricks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2016/05/super-small-web-gesture-library-alloyfinger-released/&quot;&gt;alloyfinger手势库&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</guid>
        
        <category>推荐</category>
        
        <category>文章</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>如何在页面发送通知消息</title>
        <description>&lt;p&gt;如果你的网站需要在用户登陆或者在某些特定时刻向用户发送通知。&lt;/p&gt;

&lt;p&gt;这个webapi可能会起到效果&lt;/p&gt;

&lt;h3 id=&quot;notification&quot;&gt;Notification&lt;/h3&gt;

&lt;p&gt;Web Notifications API 使页面可以发出通知，通知将被显示在页面之外的系统层面上（通常使用操作系统的标准通知机制，但是在不同的平台和浏览器上的表现会有差异）。这个功能使  web 应用可以向用户发送信息，即使应用处于空闲状态。最明显的用例之一是一个网页版电子邮件应用程序，每当用户收到了一封新的电子邮件都需要通知用户，即使用户正在使用另一个应用程序。&lt;/p&gt;

&lt;p&gt;诸如在线团队协作平台(如tower)或者聊天系统,都需要主动向用户发送通知,让用户可以及时收到最新动态&lt;/p&gt;

&lt;p&gt;tower就是通过这个接口像用户发送通知消息的。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;权限&lt;/h3&gt;

&lt;p&gt;使用Notification接口时需要像用户发送授权请求(如获取用户地址位置信息等需要用户隐私的接口都需要用户授权)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Notification.requestPermission( function(status) {

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;仅当status为granted时表示用户接受通知&lt;/p&gt;

&lt;p&gt;status有三种状态:default,granted,denied&lt;/p&gt;

&lt;p&gt;*default一般是用户未处理授权请求&lt;/p&gt;

&lt;p&gt;*granted表示用户接受通知的授权&lt;/p&gt;

&lt;p&gt;*denied表示用户拒绝接受通知&lt;/p&gt;

&lt;h3 id=&quot;notification-1&quot;&gt;Notification对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var notification = new Notification(title,{
    body:string,
    icon:imageUrl
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notification对象有三个参数,分别是通知标题,通知内容,还有图标&lt;/p&gt;

&lt;p&gt;显示效果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160701/notification.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;回调函数&lt;/h3&gt;

&lt;p&gt;notification有4个回调函数&lt;/p&gt;

&lt;p&gt;*onshow:当通知被显示给用户时触发。&lt;/p&gt;

&lt;p&gt;*onclick:当用户点击通知时触发。&lt;/p&gt;

&lt;p&gt;*onclose:当通知被关闭时触发。&lt;/p&gt;

&lt;p&gt;*onerror:当通知发生错误的时候触发。这通常是因为通知由于某些原因而无法显示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Notification.requestPermission( function(status) {

    var notification = new Notification(&quot;标题&quot;);

    notification.onshow = function(){};

    notification.onclick = function(){};

    notification.onclose = function(){};

    notification.onerror = function(){};

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/notification/Using_Web_Notifications&quot;&gt;接口文档&lt;/a&gt;);&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E6%B6%88%E6%81%AF/</guid>
        
        <category>通知</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>js节流throttle函数</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;节流函数&lt;/h2&gt;

&lt;p&gt;在前端页面,常出现用户频繁操作dom元素导致需要频繁更新视图或者发送请求。&lt;/p&gt;

&lt;p&gt;如果是后者的话,还可能会出现异步请求结果返回与发送时间的不顺序。&lt;/p&gt;

&lt;p&gt;常用于解决这种问题的一个方法就是通过节流函数,把用户短时间内的频繁操作进行累加,最后一次执行&lt;/p&gt;

&lt;p&gt;这样不仅提高性能而且更防止了上面提到的异步请求时间不同步的问题&lt;/p&gt;

&lt;p&gt;在前端实现节流函数一般是使用定时器实现&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;最简单的节流函数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function throttle(){
    if(timer){
        clearTimer(timer)
    }
    timer = setTimeout(function(){},delay);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是最简单的节流函数。通过判断是否已经存在定时器,过滤掉用户之前的操作,直到delay计时完才进行函数执行&lt;/p&gt;

&lt;h3 id=&quot;underscorethrottle&quot;&gt;underscore的throttle&lt;/h3&gt;

&lt;p&gt;underscore是一个又好又快又小的库,快主要是因为他是采用函数式编程(来源于一位老师的话)&lt;/p&gt;

&lt;p&gt;underscore也听过了如上的throttle函数(&lt;a href=&quot;http://underscorejs.org/#throttle&quot;&gt;英文文档&lt;/a&gt;,&lt;a href=&quot;http://www.css88.com/doc/underscore/#throttle&quot;&gt;中文文档&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;来自官方的一个使用例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var throttled = _.throttle(updatePosition, 100);
$(window).scroll(throttled);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;window的resize和scroll都是会频繁触犯事件的。&lt;/p&gt;

&lt;p&gt;所以通过throttle函数加以过滤可以大大提高渲染性能&lt;/p&gt;

&lt;h3 id=&quot;vuedebounce&quot;&gt;vue的debounce&lt;/h3&gt;

&lt;p&gt;vue框架自带的input的debounce实现也是节流函数的一种。(&lt;a href=&quot;https://vuejs.org/guide/forms.html#debounce&quot;&gt;文档&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;并且对于点击等用户主动触发的事件同样可以通过设置debounce来实现。&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Jun 2016 18:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/js%E8%8A%82%E6%B5%81throttle%E5%87%BD%E6%95%B0/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/js%E8%8A%82%E6%B5%81throttle%E5%87%BD%E6%95%B0/</guid>
        
        <category>throttle</category>
        
        <category>节流</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>web scroll的滚动惯性</title>
        <description>&lt;p&gt;在上个公司的最后一个版本。( &lt;a href=&quot;http://ichuanyi.com/m/page/tomorrow_recommend/&quot;&gt;传送门&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;入口放在app的主页,所以对页面的动画效果和性能(流畅度)有较大的要求&lt;/p&gt;

&lt;p&gt;页面的在交互上做了较多动画,属于交互比较复杂的单页应用&lt;/p&gt;

&lt;p&gt;其中用户在点击顶部的”地址栏”,底部的”再推荐”,以及无推荐次数之后点击”再推荐” 这三部分弹出来的页面&lt;/p&gt;

&lt;p&gt;是显示在原本主要内容层级之上的,position值为fixed&lt;/p&gt;

&lt;p&gt;在提测时候发现在native内滚动这种长页面的时候,当用户手一离开屏幕时就会停止滚动&lt;/p&gt;

&lt;p&gt;该开始以为是用户的一系列touch事件在dom冒泡了。&lt;/p&gt;

&lt;p&gt;然后在滚动的元素容器设置了event.stopPropagation()事件阻止所有事件的冒泡&lt;/p&gt;

&lt;p&gt;发现并没有什么乱用&lt;/p&gt;

&lt;p&gt;最后在mozilla的开发者文档找到了-webkit-overflow-scrolling&lt;/p&gt;

&lt;p&gt;然后通过设置该属性值为touch竟然生效了!!!!!!!&lt;/p&gt;

&lt;p&gt;!!!!!&lt;/p&gt;

&lt;p&gt;mozilla对该属性是这么描述的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   The -webkit-overflow-scrolling CSS property controls whether or not touch devices use momentum-based scrolling for the given element.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该css属性控制是否滚动是基于动量的。。。这翻译听不下去了&lt;/p&gt;

&lt;p&gt;就是看你滚动是否是需要滚行吧!!这么翻译果然好多了&lt;/p&gt;

&lt;p&gt;该属性可设置两种值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto:设置为auto时,用户的手离开屏幕即停止滚动

touch:设置为touch时,用户手离开屏幕时会基于之前的动量递减(即保持一定的惯性)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-overflow-scrolling&quot;&gt;官方解释&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jun 2016 08:00:00 +0800</pubDate>
        <link>http://chenbingshu.com///2016/webscroll%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%83%AF%E6%80%A7/</link>
        <guid isPermaLink="true">http://chenbingshu.com///2016/webscroll%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%83%AF%E6%80%A7/</guid>
        
        <category>scroll</category>
        
        <category>惯性</category>
        
        
        <category>前端</category>
        
      </item>
    
  </channel>
</rss>
